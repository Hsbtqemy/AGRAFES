"""TEI "analyse" exporter.

Produces a well-formed, UTF-8 encoded TEI XML file from a document's units.
All text is XML-escaped. Characters invalid in XML 1.0 are stripped.
See docs/DECISIONS.md ADR-009.
"""

from __future__ import annotations

import re
import sqlite3
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Optional


# Characters invalid in XML 1.0 (as a compiled pattern to strip)
# Allowed: #x9 (TAB), #xA (LF), #xD (CR), #x20-#xD7FF, #xE000-#xFFFD, #x10000-#x10FFFF
_XML10_INVALID = re.compile(
    r"[^\x09\x0A\x0D\x20-\uD7FF\uE000-\uFFFD\U00010000-\U0010FFFF]"
)


def strip_xml10_invalid(text: str) -> str:
    """Remove characters that are illegal in XML 1.0."""
    return _XML10_INVALID.sub("", text)


def xml_escape(text: str) -> str:
    """Escape XML special characters and strip XML 1.0 invalid chars."""
    text = strip_xml10_invalid(text)
    # xml.etree handles escaping automatically; this function is exposed
    # as a standalone utility for callers that build XML manually.
    text = text.replace("&", "&amp;")
    text = text.replace("<", "&lt;")
    text = text.replace(">", "&gt;")
    text = text.replace('"', "&quot;")
    text = text.replace("'", "&apos;")
    return text


def _get_document(conn: sqlite3.Connection, doc_id: int) -> sqlite3.Row:
    row = conn.execute(
        "SELECT * FROM documents WHERE doc_id = ?", (doc_id,)
    ).fetchone()
    if row is None:
        raise ValueError(f"Document not found: doc_id={doc_id}")
    return row


def _get_units(conn: sqlite3.Connection, doc_id: int) -> list[sqlite3.Row]:
    return conn.execute(
        """
        SELECT unit_id, unit_type, n, external_id, text_norm, meta_json
        FROM units
        WHERE doc_id = ?
        ORDER BY n
        """,
        (doc_id,),
    ).fetchall()


def export_tei(
    conn: sqlite3.Connection,
    doc_id: int,
    output_path: str | Path,
    include_structure: bool = False,
) -> Path:
    """Export a document as TEI XML.

    Args:
        conn: SQLite connection.
        doc_id: Document to export.
        output_path: Destination file path (.xml).
        include_structure: If True, also emit <head> elements for structure units.
                           Default False (only line units in body).

    Returns:
        The resolved output path.
    """
    output_path = Path(output_path)
    doc = _get_document(conn, doc_id)
    units = _get_units(conn, doc_id)

    title = strip_xml10_invalid(doc["title"] or "")
    language = strip_xml10_invalid(doc["language"] or "")
    source_path = strip_xml10_invalid(doc["source_path"] or "")
    created_at = strip_xml10_invalid(doc["created_at"] or "")

    # Build XML using ElementTree so escaping is automatic
    ET.register_namespace("", "http://www.tei-c.org/ns/1.0")
    tei = ET.Element("TEI", {"xmlns": "http://www.tei-c.org/ns/1.0"})

    # ── teiHeader ──────────────────────────────────────────────────────────────
    header = ET.SubElement(tei, "teiHeader")

    file_desc = ET.SubElement(header, "fileDesc")

    title_stmt = ET.SubElement(file_desc, "titleStmt")
    title_el = ET.SubElement(title_stmt, "title")
    title_el.text = title

    pub_stmt = ET.SubElement(file_desc, "publicationStmt")
    pub_p = ET.SubElement(pub_stmt, "p")
    pub_p.text = f"Generated by multicorpus_engine on {created_at}"

    source_desc = ET.SubElement(file_desc, "sourceDesc")
    source_p = ET.SubElement(source_desc, "p")
    source_p.text = source_path or "unknown"

    profile = ET.SubElement(header, "profileDesc")
    lang_usage = ET.SubElement(profile, "langUsage")
    lang_el = ET.SubElement(lang_usage, "language", {"ident": language})
    lang_el.text = language

    # ── text / body ────────────────────────────────────────────────────────────
    text_el = ET.SubElement(tei, "text")
    body = ET.SubElement(text_el, "body")
    div = ET.SubElement(body, "div")

    for unit in units:
        unit_type = unit["unit_type"]
        unit_id = unit["unit_id"]
        n = unit["n"]
        ext_id = unit["external_id"]
        text_norm = strip_xml10_invalid(unit["text_norm"] or "")

        if unit_type == "line":
            attrs: dict[str, str] = {
                "xml:id": f"u{unit_id}",
                "n": str(ext_id if ext_id is not None else n),
            }
            p = ET.SubElement(div, "p", attrs)
            p.text = text_norm
        elif unit_type == "structure" and include_structure:
            head = ET.SubElement(div, "head", {"xml:id": f"s{unit_id}"})
            head.text = text_norm

    # ── Serialize with UTF-8 declaration ──────────────────────────────────────
    output_path.parent.mkdir(parents=True, exist_ok=True)

    tree = ET.ElementTree(tei)
    ET.indent(tree, space="  ")  # pretty-print (Python 3.9+)

    with open(output_path, "w", encoding="utf-8") as f:
        f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
        tree.write(f, encoding="unicode", xml_declaration=False)
        f.write("\n")

    return output_path
